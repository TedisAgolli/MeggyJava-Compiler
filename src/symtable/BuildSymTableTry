package ast_visitors;

import ast.node.BoolType;
import ast.node.ButtonType;
import ast.node.ByteType;
import ast.node.ClassType;
import ast.node.ColorArrayType;
import ast.node.ColorType;
import ast.node.Formal;
import ast.node.IType;
import ast.node.IntArrayType;
import ast.node.IntType;
import ast.node.MethodDecl;
import ast.node.Program;
import ast.node.ToneType;
import ast.node.TopClassDecl;
import ast.node.VarDecl;
import ast.node.VoidType;
import ast.visitor.DepthFirstVisitor;
import exceptions.InternalException;
import exceptions.SemanticException;
import java.io.PrintStream;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import symtable.ClassSTE;
import symtable.MethodSTE;
import symtable.NamedScopeSTE;
import symtable.STE;
import symtable.Signature;
import symtable.SymTable;
import symtable.Type;
import symtable.VarSTE;

public class BuildSymTableTry extends DepthFirstVisitor {
    private SymTable mCurrentST = new SymTable();
    private ClassSTE mCurrentClass;
    private boolean mError = false;
    private boolean mInMethod = false;
    private int dupcount = 0;

    public SymTable getSymTable() {
        return this.mCurrentST;
    }

    private boolean checkForConflict(String string, int n, int n2) {
        if (this.mCurrentST.lookupInnermost(string) != null) {
            this.mError = true;
            System.err.println("[" + n + "," + n2 + "] Redefined symbol " + string);
            return true;
        }
        return false;
    }

    private Type getType(IType iType) {
        if (iType == null) {
            throw new InternalException("unexpected null argument");
        }
        Type type = Type.INT;
        if (iType instanceof IntArrayType) {
            type = Type.INT_ARRAY;
        }
        if (iType instanceof ColorArrayType) {
            type = Type.COLOR_ARRAY;
        }
        if (iType instanceof BoolType) {
            type = Type.BOOL;
        }
        if (iType instanceof ByteType) {
            type = Type.BYTE;
        }
        if (iType instanceof ColorType) {
            type = Type.COLOR;
        }
        if (iType instanceof ButtonType) {
            type = Type.BUTTON;
        }
        if (iType instanceof ToneType) {
            type = Type.TONE;
        }
        if (iType instanceof IntType) {
            type = Type.INT;
        }
        if (iType instanceof VoidType) {
            type = Type.VOID;
        }
        if (iType instanceof ClassType) {
            type = Type.getClassType((String)((ClassType)iType).getName());
        }
        return type;
    }

    public void outProgram(Program program) {
        if (this.mError) {
            throw new SemanticException("Errors found while building symbol table");
        }
    }

    public void outVarDecl(VarDecl varDecl) {
        if (!this.checkForConflict(varDecl.getName(), varDecl.getLine(), varDecl.getPos())) {
            VarSTE varSTE;
            if (this.mInMethod) {
                boolean bl = false;
                boolean bl2 = false;
                varSTE = new VarSTE(varDecl.getName(), this.getType(varDecl.getType()), bl, bl2);
            } else {
                boolean bl = true;
                boolean bl3 = false;
                varSTE = new VarSTE(varDecl.getName(), this.getType(varDecl.getType()), bl, bl3);
            }
            this.mCurrentST.insert((STE)varSTE);
        }
    }

    public void inMethodDecl(MethodDecl methodDecl) {
        MethodSTE methodSTE;
        Formal formal;
        this.mInMethod = true;
        Iterator iterator = methodDecl.getFormals().iterator();
        LinkedList<Type> linkedList = new LinkedList<Type>();
        while (iterator.hasNext()) {
            formal = (Formal)iterator.next();
            linkedList.add(this.getType(formal.getType()));
        }
        formal = new Signature(this.getType(methodDecl.getType()), linkedList);
        if (!this.checkForConflict(methodDecl.getName(), methodDecl.getLine(), methodDecl.getPos())) {
            methodSTE = new MethodSTE(methodDecl.getName(), (Signature)formal, methodDecl, this.mCurrentClass.getName() + methodDecl.getName());
            this.mCurrentST.insertAndPushScope((NamedScopeSTE)methodSTE);
        } else {
            methodSTE = new MethodSTE(methodDecl.getName() + "bogus" + this.dupcount++, (Signature)formal, methodDecl, this.mCurrentClass.getName() + methodDecl.getName());
            this.mCurrentST.insertAndPushScope((NamedScopeSTE)methodSTE);
        }
        boolean bl = false;
        boolean bl2 = true;
        methodSTE = new VarSTE("this", Type.getClassType((String)this.mCurrentClass.getName()), bl, bl2);
        this.mCurrentST.insert((STE)methodSTE);
        for (Formal formal2 : methodDecl.getFormals()) {
            if (this.checkForConflict(formal2.getName(), formal2.getLine(), formal2.getPos())) continue;
            bl = false;
            bl2 = true;
            methodSTE = new VarSTE(formal2.getName(), this.getType(formal2.getType()), bl, bl2);
            this.mCurrentST.insert((STE)methodSTE);
        }
    }

    public void outMethodDecl(MethodDecl methodDecl) {
        this.mCurrentST.popScope();
        this.mInMethod = false;
    }

    public void inTopClassDecl(TopClassDecl topClassDecl) {
        ClassSTE classSTE = !this.checkForConflict(topClassDecl.getName(), topClassDecl.getLine(), topClassDecl.getPos()) ? new ClassSTE(topClassDecl.getName(), false, null) : new ClassSTE(topClassDecl.getName() + "bogus" + this.dupcount++, false, null);
        this.mCurrentClass = classSTE;
        this.mCurrentST.insertAndPushScope((NamedScopeSTE)classSTE);
    }

    public void outTopClassDecl(TopClassDecl topClassDecl) {
        this.mCurrentST.popScope();
    }
}
